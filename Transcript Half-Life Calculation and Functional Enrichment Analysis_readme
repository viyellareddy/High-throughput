Transcript Half-Life Calculation and Functional Enrichment Analysis
Objective:
This project aims to calculate the transcript half-lives for yeast genes using a 60-minute time series dataset. We will use three sets of time series data and calculate the average half-life for each transcript. Then, we'll identify the genes with very high (top 10%) and very low (bottom 10%) half-lives, followed by a functional enrichment analysis.

Step 1: Load and Prepare the Data

We first load the yeast decay time course data from the provided file. This data contains three replicates for each transcript, and we calculate the half-lives based on these replicates.

Loading Data:
The DecayTimecourse.txt file is loaded using pandas, and the necessary columns for each time course replicate are extracted.
python
Copy code
import pandas as pd
import numpy as np
data = pd.read_csv('DecayTimecourse.txt', sep='\t')
Extract Time Course Data:
We extract three different sets of time series data for each transcript to calculate the half-lives for each replicate individually.
python
Copy code
timecourse_1 = pd.DataFrame(data[data.columns[1:10]])
timecourse_2 = pd.DataFrame(data[data.columns[10:19]])
timecourse_3 = pd.DataFrame(data[data.columns[19:28]])
Step 2: Log Transformation and Regression Model

To compute the decay rate, we apply a logarithmic transformation to the data. We then fit a regression model (Ordinary Least Squares) to estimate the decay rate (slope) for each transcript.

python
Copy code
log_timecourse_1 = np.log(timecourse_1)
import statsmodels.api as sm
results1 = {}
for i in range(len(log_timecourse_1.index)):
    if log_timecourse_1.iloc[i].isnull().any():
        x = log_timecourse_1.columns[~np.isnan(log_timecourse_1.iloc[i])]
        y = log_timecourse_1.iloc[i].dropna().values.reshape(-1, 1)
        x = sm.add_constant(x)
        model = sm.OLS(y, x).fit()
        slope = model.params[1]
        results1[log_timecourse_1.index[i]] = slope
We repeat this step for all three time series (replicates).

Step 3: Calculate Half-Lives

Using the slope obtained from the regression model, we calculate the half-life for each gene. The formula for calculating the half-life is:

Half-life
=
ln
⁡
(
2
)
slope
Half-life= 
slope
ln(2)
​	
 
python
Copy code
half_life1 = {}
for i, slope in results1.items():
    half_life = np.log(2) / slope
    half_life1[i] = half_life
We repeat the above process for the other two time courses to get half_life2 and half_life3.

Step 4: Calculate the Average Half-Life

Once we have the half-life values for each replicate, we compute the average half-life for each transcript across the three replicates.

python
Copy code
import numpy as np
average_half_life = np.mean([df1, df2, df3])
Step 5: Identify Top and Bottom 10% of Genes

We sort the genes based on their average half-lives and identify the top 10% (long half-lives) and bottom 10% (short half-lives) of genes.

python
Copy code
df_sorted = df4.sort_values('half_life')
top_genes = df_sorted.head(int(len(df_sorted) * 0.1))
bottom_genes = df_sorted.tail(int(len(df_sorted) * 0.1))
Step 6: Functional Enrichment Analysis

Using the top and bottom 10% genes, we perform functional enrichment analysis using Gene Ontology (GO) annotations from external tools like gProfiler and GO TermFinder.

